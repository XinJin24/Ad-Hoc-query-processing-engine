import subprocess


def read_arguments_from_file():
    # file_path = input("Enter the file path: ")
    file_path = r"C:\Users\jinxi\git_repos\Ad-Hoc-query-processing-engine\input1.txt"
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            content = file.readlines()

        keys = [
            'SELECT ATTRIBUTE(S):',
            'NUMBER OF GROUPING VARIABLES(n):',
            'GROUPING ATTRIBUTES(V):',
            'F-VECT([F]):',
            'SELECT CONDITION-VECT([σ]):',
            'HAVING_CONDITION(G):'
        ]
        parsed_data = {key: [] for key in keys}
        current_key = None

        for line in content:
            line = line.strip()
            if line in keys:
                current_key = line
            elif current_key and line:
                elements = [element.strip() for element in line.split(',')]
                parsed_data[current_key].extend(elements)

        if any(len(parsed_data[key]) == 0 for key in keys):
            raise ValueError("Some keys are missing data.")

        return parsed_data

    except FileNotFoundError:
        print("File not found. Please check the path and try again.")
        return None
    except ValueError as ve:
        print(ve)
        return None
    except UnicodeDecodeError:
        print("Encoding error: Please check the file encoding. It may not be UTF-8.")
        return None
    except Exception as e:
        print(f"An error occurred: {e}")
        return None


def get_arguments_manually():
    print("Please enter the 6 arguments for the Phi Operator:")
    return {
        'SELECT_ATTRIBUTE(S)': input("Enter SELECT ATTRIBUTE(S) (e.g., cust, 1_sum_quant, 2_sum_quant, 3_sum_quant): "),
        'NUMBER_OF_GROUPING_VARIABLES(n)': input("Enter NUMBER OF GROUPING VARIABLES(n) (e.g., 3): "),
        'GROUPING_ATTRIBUTES(V)': input("Enter GROUPING ATTRIBUTES(V) (e.g., cust): "),
        'F-VECT([F])': input(
            "Enter F-VECT([F]) (e.g., 1_sum_quant, 1_avg_quant, 2_sum_quant, 3_sum_quant, 3_avg_quant): "),
        'SELECT_CONDITION-VECT([σ])': input(
            "Enter SELECT CONDITION-VECT([σ]) (e.g., 1.state='NY', 2.state='NJ', 3.state='CT'): "),
        'HAVING_CONDITION(G)': input(
            "Enter HAVING_CONDITION(G) (e.g., 1_sum_quant > 2 * 2_sum_quant or 1_avg_quant > 3_avg_quant): ")
    }


def get_phi_operator_arguments():
    choice = input("Do you want to enter arguments manually or from a file? (Type 'manual' or 'file'): ").lower()
    if choice == 'file':
        return read_arguments_from_file()
    elif choice == 'manual':
        return get_arguments_manually()
    else:
        print("Invalid choice. Please enter 'manual' or 'file'.")
        return get_phi_operator_arguments()


def step1():
    arguments = get_phi_operator_arguments()
    if arguments is not None:
        print("Phi Operator Arguments:", arguments)
        return arguments


def step2(body):
    """
    This is the generator code. It should take in the MF structure and generate the code
    needed to run the query. That generated code should be saved to a
    file (e.g. _generated.py) and then run.
    """
    # Note: The f allows formatting with variables.
    #       Also, note the indentation is preserved.
    tmp = f"""
import os
import psycopg2
import psycopg2.extras
import tabulate
from _H_class_generated import H
import collections
from dotenv import load_dotenv

# DO NOT EDIT THIS FILE, IT IS GENERATED BY generator.py

def query():
    load_dotenv()

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect("dbname="+dbname+" user="+user+" password="+password,
                            cursor_factory=psycopg2.extras.DictCursor)

    cur = conn.cursor()
    cur.execute("SELECT * FROM sales")
    rows = cur.fetchall()
    
    mf_structure = collections.defaultdict(H)
    {body}

    _global = []
    return tabulate.tabulate(_global,
                        headers="keys", tablefmt="psql")

def main():
    print(query())

if "__main__" == __name__:
    main()
    """

    # Write the generated code to a file
    with open("_generated.py", "w", encoding='utf-8') as file:
        file.write(tmp)
    # Execute the generated code
    subprocess.run(["python", "_generated.py"])


def generate_h_table(arguments):
    grouping_attributes = arguments['GROUPING ATTRIBUTES(V):']
    aggregate_functions = arguments['F-VECT([F]):']

    class_definition = "class H:\n"
    class_definition += "    def __init__(self):\n"
    class_definition += "        self.attributes = {}\n"

    for attr in grouping_attributes:
        formatted_attr = f"_{attr}" if attr[0].isdigit() else attr
        class_definition += f"        self.attributes['{formatted_attr}'] = None\n"

    for func in aggregate_functions:
        formatted_func = f"_{func}" if func[0].isdigit() else func
        class_definition += f"        self.attributes['{formatted_func}'] = None\n"

    class_definition += """
    def __getitem__(self, key):
        return self.attributes.get(key, None)

    def __setitem__(self, key, value):
        self.attributes[key] = value

    def __repr__(self):
        return f'H({self.attributes})'
    """

    filename = "_H_class_generated.py"
    with open(filename, 'w') as file:
        file.write(class_definition)

    print(f"Class H has been generated and saved to {filename}")
    return filename


def initializing_H_table(grouping_attributes, aggregate_functions):
    indentation = "    "
    generated_code = []

    formatted_group_keys = ", ".join([f"key_{attr}" for attr in grouping_attributes])
    group_dict_access = f"mf_structure[({formatted_group_keys})]"

    if 0 in aggregate_functions:
        aggregate_info = [(f[0], f[1], f[2]) for f in aggregate_functions[0]]
        for aggregate in aggregate_info:
            if "avg" in aggregate[1]:
                generated_code.append(f"{indentation}count_{aggregate[0]} = collections.defaultdict(int)")
                break

    generated_code.append("for row in rows:")

    schema_indices = {'cust': '0', 'prod': '1', 'day': '2', 'month': '3',
                      'year': '4', 'state': '5', 'quant': '6', "date": '7'}
    for attribute in grouping_attributes:
        generated_code.append(f"{indentation * 2}key_{attribute} = row[{schema_indices[attribute]}]")

    if 0 in aggregate_functions:
        aggregate_attr_set = set(info[2] for info in aggregate_info)
        for aggregate_attr in aggregate_attr_set:
            generated_code.append(f"{indentation * 2}{aggregate_attr} = row[{schema_indices[aggregate_attr]}]")

    grouping_conditions = " and ".join([f"{group_dict_access}['{attr}']" for attr in grouping_attributes])
    generated_code.append(f"{indentation * 2}if not ({grouping_conditions}):")
    for attribute in grouping_attributes:
        generated_code.append(f"{indentation * 3}{group_dict_access}['{attribute}'] = key_{attribute}")

    return "\n".join(generated_code)
def templating_aggregates(aggregate_definitions):
    aggregate_mapping = {}
    for definition in aggregate_definitions:
        parts = definition.split("_")
        grouping_variable_index = int(parts[0])
        aggregate_function = parts[1]
        attribute_name = parts[2]

        if grouping_variable_index not in aggregate_mapping:
            aggregate_mapping[grouping_variable_index] = []
        aggregate_mapping[grouping_variable_index].append((definition, aggregate_function, attribute_name))

    return aggregate_mapping

def scan_to_compute_aggregates(aggregate_definitions):
    aggregate_mapping = {}
    for definition in aggregate_definitions:
        parts = definition.split("_")
        grouping_variable_index = int(parts[0])
        aggregate_function = parts[1]
        attribute_name = parts[2]

        if grouping_variable_index not in aggregate_mapping:
            aggregate_mapping[grouping_variable_index] = []
        aggregate_mapping[grouping_variable_index].append((definition, aggregate_function, attribute_name))

    return aggregate_mapping


if "__main__" == __name__:
    body = ""
    phi_arguments = step1()
    grouping_attributes = phi_arguments['GROUPING ATTRIBUTES(V):']
    aggregate_functions = phi_arguments['F-VECT([F]):']
    aggregate_functions = templating_aggregates(aggregate_functions)
    file_name = generate_h_table(phi_arguments)

    body += initializing_H_table(grouping_attributes, aggregate_functions)
    body += scan_to_compute_aggregates()
    step2(body)
